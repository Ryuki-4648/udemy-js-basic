/**
 * プリミティブ型とオブジェクト（型）
 * データ型にはこの２種類が存在する
 * 
 * 
 * プリミティブ型
 * ・変数には「値」が格納される
 * ・一度作成すると、その値を変更することはできない
 * ・immutable(不変)な性質を持つ
 * 
 * 
 * letで再代入できるから不変ではないのでは・・・？
 * 　↓↓
*/

// メモリ空間
let hoge = 'hello';
// まず文字列helloが定義されると、アドレス「1番地」に格納されるイメージ。
// 変数が「hello」という文字列が格納されているアドレスに参照を保持している状態。

hoge = 'bye';
// helloとは別のアドレスにbyeが格納される。
// 変数hogeに再代入すると、hogeの「参照」がbyeに向けて変更される
// 初めに定義したhelloそのものは変更されない

// 再代入：変数hogeの持つ値への参照が切り替わる



/**
 * オブジェクト型
 * ・変数には「参照：が格納される
 * ・値を変更することができる
 * ・mutable(可変)な性質を持つ
 * 
*/

// メモリ空間
let fuga = {
  prop: 'hello',
}
/**
 * →：参照を保持
 * 
 * fuga　→　{...}への参照
 * {....}　→　{prop}プロパティ　（オブジェクトが格納している実態が存在しているアドレスへ参照帆保持している）
 * {prop}プロパティ　→　'hello'
 * 
 * hello：メモリ空間のどこかに値が存在していて、それへの参照をオブジェクトは保持している
 * 
 * オブジェクトの中身を変えても、変数→オブジェクトへの参照先は変わらないためオブジェクトはミュータブルと言える。
 * 
 * 
 * オブジェクト：名前（プロパティ）付きの参照を管理する入れ物
*/






/**
 * 参照とコピー
*/



// プリミティブ型
let a = 'hello';
let b = a; // copy
console.log(a, b); // hello hello

b = 'bye';
console.log(a, b); // hello bye
// 変数aは文字列helloを維持している



// オブジェクト型
let c = {
  prop: 'hello'
}

let d = c; // copy
console.log(c, d); // 両方prop: hello

d.prop = 'bye';
console.log(c, d); // 両方prop: yeになってしまう
// cとdが同じオブジェクトへの参照を保持している！！
// 片方を変更すると、もう片方も変わってしまう





// 新しいオブジェクトを設定した場合
let e = {
  prop: 'hello'
}

let f = e;
f = {}; // 新しくオブジェクトを作成。
// 変数fの参照が新しいオブジェクトに。オブジェクトの実態は別のものになるため、変数f,eそれぞれに変更を加えても互いに影響しない
console.log(e, f);
// eは設定値が保存されたまま。fは新しいオブジェクトへの参照を保持する




// まとめ
// プリミティブ型のコピー：参照先の「値」がコピーされる
// オブジェクトのコピー：オブジェクトへの「参照」がコピーされる